# GDB MCP Server integration via FastMCP (basic)

python
import threading
import traceback

try:
    import gdb  # provided by GDB's Python
except Exception as e:
    raise RuntimeError("This script requires GDB with Python support") from e

_mcp_thread = None
_mcp_running = False


def _run_gdb_command(cmd: str) -> str:
    """Execute a GDB command on GDB's main thread and return output.

    No timeout handling is provided.
    """
    result = {"out": "", "err": None, "done": False}
    cond = threading.Condition()

    def _do_exec():
        try:
            out = gdb.execute(cmd, to_string=True)
            with cond:
                result["out"] = out
                result["done"] = True
                cond.notify_all()
        except Exception as ex:
            with cond:
                result["err"] = f"{type(ex).__name__}: {ex}"
                result["done"] = True
                cond.notify_all()

    gdb.post_event(_do_exec)
    with cond:
        while not result["done"]:
            cond.wait(timeout=0.05)
    if result["err"]:
        return f"ERROR: {result['err']}"
    return result["out"]


def _build_fastmcp_app():
    """Construct and return a FastMCP server instance and SSE runner."""
    try:
        import fastmcp  # type: ignore
    except Exception as e:
        gdb.write(f"[mcp] Failed to import fastmcp: {e}\n")
        return None, None

    ServerClass = getattr(fastmcp, "FastMCP", None) or getattr(fastmcp, "Server", None)
    if ServerClass is None:
        gdb.write("[mcp] fastmcp does not expose FastMCP/Server class\n")
        return None, None

    try:
        app = ServerClass(
            name="gdb-mcp",
            version="0.1.0",
            description="Lightweight GDB MCP server exposing a gdb-command tool",
        )
    except TypeError:
        app = ServerClass("gdb-mcp", "0.1.0", "Lightweight GDB MCP server")

    def _tool_impl(command: str) -> str:
        return _run_gdb_command(command)

    registered = False
    tool_method = getattr(app, "tool", None)
    if callable(tool_method):
        try:
            tool_method(name="gdb-command", description="Run a GDB command")(_tool_impl)
            registered = True
        except Exception:
            try:
                tool_method("gdb-command")(_tool_impl)
                registered = True
            except Exception:
                pass

    if not registered and hasattr(app, "register_tool"):
        try:
            app.register_tool(handler=_tool_impl, name="gdb-command", description="Run a GDB command")
            registered = True
        except Exception:
            pass

    if not registered and hasattr(app, "add_tool"):
        try:
            app.add_tool(handler=_tool_impl, name="gdb-command", description="Run a GDB command")
            registered = True
        except Exception:
            pass

    if not registered:
        try:
            module_tool = getattr(fastmcp, "tool", None)
            if callable(module_tool):
                decorated = module_tool(name="gdb-command", description="Run a GDB command")(_tool_impl)
                if hasattr(app, "register_tool"):
                    app.register_tool(decorated)
                else:
                    tools_attr = getattr(app, "tools", None)
                    if isinstance(tools_attr, list):
                        tools_attr.append(decorated)
                registered = True
        except Exception:
            pass

    if not registered:
        gdb.write("[mcp] Unable to register gdb-command tool with fastmcp\n")
        return None, None

    run_sse = None
    if hasattr(app, "run_sse"):
        run_sse = lambda host, port: app.run_sse(host=host, port=port)
    else:
        sse_mod = getattr(fastmcp, "sse", None)
        if sse_mod is not None and hasattr(sse_mod, "run"):
            run_sse = lambda host, port: sse_mod.run(app, host=host, port=port)
        elif hasattr(app, "run"):
            def _runner(host, port):
                try:
                    app.run(host=host, port=port, transport="sse")
                except TypeError:
                    app.run(host=host, port=port)
            run_sse = _runner

    if run_sse is None:
        gdb.write("[mcp] Could not locate an SSE runner in fastmcp\n")
        return None, None

    return app, run_sse


class McpServerCommand(gdb.Command):
    """Start a FastMCP SSE server inside GDB.

Usage:
  mcp-server <host> <port>

Example:
  mcp-server 127.0.0.1 3333
    """

    def __init__(self):
        super(McpServerCommand, self).__init__("mcp-server", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        global _mcp_thread, _mcp_running
        argv = gdb.string_to_argv(arg)
        if len(argv) != 2:
            raise gdb.GdbError("usage: mcp-server <host> <port>")
        host, port_str = argv[0], argv[1]
        try:
            port = int(port_str)
        except ValueError:
            raise gdb.GdbError("port must be an integer")

        if _mcp_running:
            gdb.write("[mcp] Server already running\n")
            return

        app, runner = _build_fastmcp_app()
        if app is None or runner is None:
            raise gdb.GdbError("Failed to initialize FastMCP server; see messages above")

        def _serve():
            global _mcp_running
            _mcp_running = True
            try:
                gdb.write(f"[mcp] Starting SSE server on {host}:{port}...\n")
                runner(host, port)
            except Exception:
                traceback.print_exc()
            finally:
                _mcp_running = False
                gdb.write("[mcp] Server stopped\n")

        _mcp_thread = threading.Thread(target=_serve, name="gdb-mcp-sse", daemon=True)
        _mcp_thread.start()
        gdb.write("[mcp] Server launched in background.\n")


McpServerCommand()
end

